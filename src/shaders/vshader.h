#ifndef _V_SHADER_H_
#define _V_SHADER_H_

// vshader.glsl as a string so that it can be included in the binary
static char * V_SHADER_STR = "#version 120 \n"
"\n"
"attribute vec4 vPosition;\n"
"attribute vec4 vColor;\n"
"attribute vec4 vNormal;\n"
"varying vec4 color;\n"
"\n"
"uniform mat4 ctm; // Object Current Transformation Matrix\n"
"uniform mat4 model_view_matrix; // Model view matrix (look_at())\n"
"uniform mat4 projection_matrix; // Projection matrix (ortho() for now)\n"
"uniform vec4 light_position; // position of the light sphere\n"
"uniform int is_shadow; // determines if should draw shadow or not\n"
"uniform float plane_height; // current height of the plane to project onto\n"
"\n"
"varying vec4 N;\n"
"varying vec4 L;\n"
"varying vec4 V;\n"
"varying float distance;\n"
"\n"
"void main() {\n"  
"\n"
" 	// if(is_shadow == 0) {\n"
" 	if(true) {\n"
"\n"	
"		gl_Position = projection_matrix * model_view_matrix * ctm * vPosition;\n"
"		color = vColor;\n"
"\n"
"		N = normalize(model_view_matrix * ctm * vNormal);\n"
"		vec4 L_temp = model_view_matrix * (light_position - ctm * vPosition);\n"
"		L = normalize(L_temp);\n"
"		vec4 eye_point = vec4(0.0, 0.0, 0.0, 1.0);\n"
"		V = normalize(eye_point - (model_view_matrix * ctm * vPosition));\n"
"		distance = length(L_temp);\n"
"	} else {\n"
"		vec4 temp = ctm * vPosition;\n"
"		float x = light_position.x - ((light_position.y - plane_height) * ((light_position.x - temp.x) / (light_position.y - temp.y)));\n"
"		float z = light_position.z - ((light_position.y - plane_height) * ((light_position.z - temp.z) / (light_position.y - temp.y)));\n"
"		gl_Position = projection_matrix * model_view_matrix * vec4(x, plane_height, z, 1);\n"
"		color = vec4(0, 0, 0, 1);\n"
"	} \n"
"}\n";

#endif